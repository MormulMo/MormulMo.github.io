<!DOCTYPE html>
<html>
  <head>
    <title>_Яндекс__</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/Yandex.css">
  </head>
      <body>    
         
        <div><h1 id="main-title">Блог компании Яндекс.</h1></div>
        <h3 class="title"><em>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</em></h3>
        <p><font class="font">Е</font>сли ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br>тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br>иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый<br> код и новая логика. Всё это напрямую влияет на скорость работы интерфейса.</font></p>
          
          <h3 class="title"><em>Что мы измеряем</em></h3>

            <p><u>Этапы первой загрузки:</u></p>
              <ul>
                <li>подготовка;</li>
                <li>загрузка статики (HTTP-запрос и парсинг);</li>
                <li>исполнение модулей;</li>
                <li>инициализация базовых объектов;</li>
                <li>отрисовка.</li>
              </ul>

            <p><u>Этапы отрисовки любой страницы:</u></p>
              <ul>
                <li>подготовка к запросу на сервер;</li>
                <li>запрос данных с сервера;</li>
                <li>шаблонизация;</li>
                <li>обновление DOM.</li>
              </ul>

            <p>— <i>«Ок, теперь у нас есть метрики, мы можем отправить их на сервер»</i> - говорим мы<br>— <i>«Что же дальше?»</i> - вопрошаете вы<br>— <i>«А давай построим график!»</i> - отвечаем мы<br>— <i>«А что будем считать?»</i> - уточняете вы</p>

            <p><font class="font">К</font>ак вы знаете, медиана – это серединное, а не среднее значение в выборке.<br> Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br> В общем случае медиана отлично показывает, сколько грузится средний пользователь.</p>

            <p>В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br> рассказать, сколько пользователей ускорилось, а сколько замедлилось.</p>

            <p>APDEX – метрика, которая сразу говорит: хорошо или плохо. Метрика<br> работает очень просто. Мы выбираем временной интервал <code>[0; t]</code>, такой, что если<br> время показа страницы попало в него, то пользователь счастлив. Берем еще один<br> интервал, <code>(t; 4t]</code> (в четыре раза больше первого), и считаем, что если страница<br> показана за это время, то пользователь в целом удовлетворен скоростью работы,<br> но уже не настолько счастлив. <u>И применяем формулу:</u></p>

            <p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br> Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br> хорошо или плохо работает почта.</p>

            <h3 class="title"><em>Как мы измеряем</em></h3>

            <p><font class="font">С</font>ейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br> причину замедления: медленнее стал отвечать сервер либо слишком долго<br> выполняется JavaScript. <u>Выглядит это примерно так:</u></p>

            <code>this.timings['look-ma-im-start'] = Date.now();<br>this.timings['look-ma-finish'] = Date.now();</code>

            <p>C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при<br>отправке рассчитываются. На этапах разница между “end” и “start” не считается,<br>а все вычисления производятся в конце:</p>

            <code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>

            <p><u>И на сервер прилетают подобные записи:</u></p>

            <code>serverResponse=50&domUpdate=60</code>

            <h3 class="title"><em>Как мы ускоряем</em></h3>

            <p><font class="font">Ч</font>тобы снизить время загрузки почты при выходе новых версий,<br> мы уже делаем следующее:</p>

              <ul>
                <li>включаем gzip;</li>
                <li>выставляем заголовки кэширования;</li>
                <li>фризим CSS, JS, шаблоны и картинки;</li>
                <li>используем CDN;</li>
              </ul>

            <p>Мы подумали: <i>«А что если хранить где-то старую версию файлов, а при выходе новой<br> передавать только diff между ней и той, которая сохранена у пользователя?»</i><br> В браузере же останется просто наложить патч на клиентe.</p>

            <p>На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,<br> RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они<br>не получили должного распространения в браузерах и на серверах.</p>

            <p>Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br>начали искать реализации diff на JS. На популярных хостингах кода нашли библиотеки:</p>
              <ul>
                <li>VCDiff</li>
                <li>google-diff-patch-match</li>
              </ul>
           <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>

           <table width="35%">
             <tr>
               <th>Библиотека</th> <th>IE 9</th> <th>Opera 12</th>
             </tr>
             <tr>
               <td>vcdiff</td> <td>8</td> <td>5</td>
             </tr>
             <tr>
               <td>google diff</td> <td>1363 </td> <td>76</td>
             </tr>
           </table>

           <p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br>где и как хранить статику на клиенте.</p>

           <p><u>Формат файла с патчами для проекта выглядит так:</u></p>

           <table border="2">
            <tr>
              <td><code>[<br>
                    {<br>
                    &nbsp&nbsp    "k": "jane.css",<br>
                    &nbsp&nbsp    "p": [patch],<br>
                    &nbsp&nbsp    "s": 4554<br>
                    &nbsp&nbsp},<br>
                    {<br>
                    &nbsp&nbsp "k": "jane.css",<br>
                    &nbsp&nbsp "p": [patch],<br>
                    &nbsp&nbsp "s": 4554<br>
                    &nbsp&nbsp}<br>
                  ]<br>
                </code></td>
             </tr>
            </table>

            <p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс.<br> У каждого объекта есть три свойства. k — названия ключа в localStorage для этого<br> ресурса. p — патч для ресурса, который сгенерировал vcdiff. s — чексумма для<br> ресурса актуальной версии, чтобы потом можно было проверить правильность<br> наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.</p>

            <p><i>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)<br></i> — итерационный метод численной оптимизации, предназначенный для<br> нахождения локального максимума/минимума нелинейного функционала<br> без ограничений.</p>

            <p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:<br>CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный для<br> проверки целостности данных.<br>md5 - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»<br> или дайджестов сообщения произвольной длины и последующей проверки их подлинности.</p>

            <p>Потому что он быстрый, компактный и легок в реализации.</p>

            <h3 class="title"><em>Итог</em></h3>

            <p><font class="font">Ф</font>актически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>

            <table border="2" width="35%">
              <tr>
                <th>Релиз</th> <th>С патчем</th> <th>Без патча</th>
              </tr>
              <tr>
                <td>7.7.20</td> <td>397</td> <td>174 549</td>
              </tr>
              <tr>
                <td>7.7.21</td> <td>383</td> <td>53 995</td>
              </tr>
              <tr>
                <td>7.7.22</td> <td>483</td> <td>3 995</td>
              </tr>
            </table>

            <p>Автор: @doochik<br>
            С++ разработик<br>
            Электронная почта: (<a href="mailto:doochik@yandex-team.ru">doochik@yandex-team.ru</a>)<br>
            Компания: <a href="yandex.ru">Яндекс</a><br>
            </p>

            <p>__________________________________</p>

            <h3 class="title"><em>Комментарии (3)</em></h3>

            <dd><p><strong>- Mogaika</strong> <a href="mailto:mogaika@yandex-team.ru">(mogaika@yandex-team.ru)</a> 30 ноября 2014 в 17:05</p>

              <blockquote><font face="Arial"> А можете привести сравнение, на сколько быстрее грузится lite версия?</blockquote></font>

              <p><strong>- JIguse</strong> <a href="mailto:mrawesome@yandex.ru">(mrawesome@yandex.ru)</a> 29 ноября 2014 в 21:30</p>

              <blockquote><font face="Arial"> Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми<br>подробностями о внутренней работе сервисов.</blockquote></font>

              <p><strong>- Brister</strong> <a href="mailto:brist89@yandex-team.ru">(brist89@yandex-team.ru)</a> 24 ноября 2014 в 13:13</p>

              <blockquote><font face="Arial">(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br> Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br> хорошо или плохо работает почта.<br><br>наверное все-таки от 0.5 до 1</blockquote></font>

              <p><strong>- alexeimois</strong> <a href="mailto:test@yandex.ru">(test@yandex.ru)</a> 22 ноября 2014 в 17:35</p>

              <blockquote><font face="Arial">Мы измеряем скорость загрузки с помощью Яндекс.Метрики:<br><a href="help.yandex.ru/metrika/reports/monitoring_timing.xml">help.yandex.ru/metrika/reports/monitoring_timing.xml</a></font></blockquote>

              <p>&copy;Яндекс, <a href="help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10</p>
              

          </dd>


          <form>
            <input value="Кнопка" type="button" name="2">
            <label>
              Name <input type="text" name="Кнопка">
            </label>
          
          </form>
          <form action="#" method="POST">
    <!-- Поле для ввода заголовка книги -->
    <!-- Так как мы редактируем, то заголовок уже предустановлен в поле -->
    <div>
        <label for="name" style="display: block;">Name</label>
        <input id="name" name="title" type="text" placeholder="enter name">

        <div style="height: 10px;"></div>

       <label style="display: block;">
            Name
            <input type="text" placeholder="enter name">
        </label>

   </div>
    <div style="height: 10px;"></div>

    <div>
        <label for="book">book</label>
        <select id="book">
            <option>1</option>
            <option selected>2</option>
        </select>
    </div>

   <!-- Поле для ввода автора книги -->
    <input name="author"  placeholder="enter pass" type="password">

   <!-- Кнопка сохранения -->
    <!-- При нажатии на неё, браузер соберёт все данные и отправит по адресу /book/war-and-peace -->

   <input value="button" type="button">
    <button type="submit">Сохранить</button>

   <div style="height: 10px;"></div>
    <div>
        <textarea rows="15" cols="15" style="width: 400px" placeholder="enter info"></textarea>
    </div>
    <div style="height: 10px;"></div>

    <div>
      DAnil
      <label><input name="mybook" type="radio" value="Mo">Mo</label>
      <label><input type="radio" name="mybook" value="Mo2">Mo2</label>
    </div>
</form>















            


       </body>
</html>